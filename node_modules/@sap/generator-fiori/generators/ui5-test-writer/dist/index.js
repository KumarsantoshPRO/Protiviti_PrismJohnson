"use strict";
exports.id = 708;
exports.ids = [708];
exports.modules = {

/***/ 74386:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.t = exports.initI18n = void 0;
const i18next_1 = __importDefault(__webpack_require__(40258));
const ui5_test_writer_i18n_json_1 = __importDefault(__webpack_require__(74940));
const NS = 'ui5-test-writer';
/**
 * Initialize i18next with the translations for this module.
 */
function initI18n() {
    return __awaiter(this, void 0, void 0, function* () {
        yield i18next_1.default.init({
            resources: {
                en: {
                    [NS]: ui5_test_writer_i18n_json_1.default
                }
            },
            lng: 'en',
            fallbackLng: 'en',
            defaultNS: NS,
            ns: [NS]
        });
    });
}
exports.initI18n = initI18n;
/**
 * Helper function facading the call to i18next.
 *
 * @param key i18n key
 * @param options additional options
 * @returns {string} localized string stored for the given key
 */
function t(key, options) {
    return i18next_1.default.t(key, options);
}
exports.t = t;
initI18n().catch(() => {
    // Ignore any errors since the write will still work
});
//# sourceMappingURL=i18n.js.map

/***/ }),

/***/ 73143:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generatePageObjectFile = exports.generateOPAFiles = void 0;
const path_1 = __webpack_require__(71017);
const mem_fs_1 = __webpack_require__(5407);
const mem_fs_editor_1 = __webpack_require__(84659);
const types_1 = __webpack_require__(44749);
const i18n_1 = __webpack_require__(74386);
/**
 * Reads the manifest for an app.
 *
 * @param fs - a reference to a mem-fs editor
 * @param basePath - the root folder of the app
 * @returns the manifest object. An exception is thrown if the manifest cannot be read.
 */
function readManifest(fs, basePath) {
    const manifest = fs.readJSON((0, path_1.join)(basePath, 'webapp/manifest.json'));
    if (!manifest) {
        throw new types_1.ValidationError((0, i18n_1.t)('error.cannotReadManifest', {
            filePath: (0, path_1.join)(basePath, 'webapp/manifest.json')
        }));
    }
    return manifest;
}
/**
 * Retrieves the application type of the main datasource (FreeStyle, FE V2 or FE V4).
 *
 * @param manifest - the app descriptor of the app
 * @returns {{ applicationType: string, hideFilterBar: boolean }} An object containing the application type and hideFilterBar flag. An exception is thrown if it can't be found or if it's not supported
 */
function getAppTypeAndHideFilterBarFromManifest(manifest) {
    var _a, _b, _c, _d, _e;
    const appTargets = (_b = (_a = manifest['sap.ui5']) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.targets;
    let hideFilterBar = false;
    let isFEV4 = false;
    for (const targetKey in appTargets) {
        const target = appTargets[targetKey];
        if (target.type === 'Component' && target.name && target.name in types_1.SupportedPageTypes) {
            isFEV4 = true;
            if (types_1.SupportedPageTypes[target.name] === 'ListReport') {
                hideFilterBar = (_e = (_d = (_c = target.options) === null || _c === void 0 ? void 0 : _c.settings) === null || _d === void 0 ? void 0 : _d.hideFilterBar) !== null && _e !== void 0 ? _e : false;
            }
        }
    }
    if (!isFEV4) {
        throw new types_1.ValidationError((0, i18n_1.t)('error.badApplicationType'));
    }
    return { applicationType: 'v4', hideFilterBar }; // For the time being, only FE V4 is supported
}
/**
 * Retrieves appID and appPath from the manifest.
 *
 * @param manifest - the app descriptor of the app
 * @param forcedAppID - the appID in case we don't want to read it from the manifest
 * @returns appID and appPath
 */
function getAppFromManifest(manifest, forcedAppID) {
    var _a;
    const appID = forcedAppID || ((_a = manifest['sap.app']) === null || _a === void 0 ? void 0 : _a.id);
    const appPath = appID === null || appID === void 0 ? void 0 : appID.split('.').join('/');
    if (!appID || !appPath) {
        throw new types_1.ValidationError((0, i18n_1.t)('error.cannotReadAppID'));
    }
    return { appID, appPath };
}
/**
 * Create the page configuration object from the app descriptor and the target key.
 *
 * @param manifest - the app descriptor of the app
 * @param targetKey - the key of the target in the manifest
 * @param forcedAppID - the appID in case we don't want to read it from the manifest
 * @returns Page configuration object, or undefined if the target type is not supported
 */
function createPageConfig(manifest, targetKey, forcedAppID) {
    var _a, _b, _c, _d, _e, _f;
    const appTargets = (_b = (_a = manifest['sap.ui5']) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.targets;
    const target = appTargets && appTargets[targetKey];
    const { appID, appPath } = getAppFromManifest(manifest, forcedAppID);
    if ((target === null || target === void 0 ? void 0 : target.type) === 'Component' &&
        (target === null || target === void 0 ? void 0 : target.name) &&
        target.name in types_1.SupportedPageTypes &&
        (target === null || target === void 0 ? void 0 : target.id) &&
        (((_d = (_c = target === null || target === void 0 ? void 0 : target.options) === null || _c === void 0 ? void 0 : _c.settings) === null || _d === void 0 ? void 0 : _d.entitySet) || ((_f = (_e = target === null || target === void 0 ? void 0 : target.options) === null || _e === void 0 ? void 0 : _e.settings) === null || _f === void 0 ? void 0 : _f.contextPath))) {
        const pageConfig = {
            appPath,
            appID,
            targetKey,
            componentID: target.id,
            template: types_1.SupportedPageTypes[target.name],
            isStartup: false
        };
        if (target.options.settings.contextPath) {
            pageConfig.contextPath = target.options.settings.contextPath;
        }
        else if (target.options.settings.entitySet) {
            pageConfig.entitySet = target.options.settings.entitySet;
        }
        return pageConfig;
    }
    else {
        return undefined;
    }
}
/**
 * Create the configuration object from the app descriptor.
 *
 * @param manifest - the app descriptor of the target app
 * @param opaConfig - parameters for the generation
 * @param opaConfig.scriptName - the name of the OPA journey file. If not specified, 'FirstJourney' will be used
 * @param opaConfig.htmlTarget - the name of the html file that will be used in the OPA journey file. If not specified, 'index.html' will be used
 * @param opaConfig.appID - the appID. If not specified, will be read from the manifest in sap.app/id
 * @param hideFilterBar - whether the filter bar should be hidden in the generated tests
 * @returns OPA test configuration object
 */
function createConfig(manifest, opaConfig, hideFilterBar) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    // General application info
    const { appID, appPath } = getAppFromManifest(manifest, opaConfig.appID);
    const config = {
        appID,
        appPath,
        pages: [],
        opaJourneyFileName: (_a = opaConfig.scriptName) !== null && _a !== void 0 ? _a : 'FirstJourney',
        htmlTarget: (_b = opaConfig.htmlTarget) !== null && _b !== void 0 ? _b : 'index.html',
        hideFilterBar
    };
    // Identify startup targets from the routes
    const appRoutes = ((_e = (_d = (_c = manifest['sap.ui5']) === null || _c === void 0 ? void 0 : _c.routing) === null || _d === void 0 ? void 0 : _d.routes) !== null && _e !== void 0 ? _e : []);
    // Find the route with an empty pattern (except for the trailing query part)
    const startupRoute = appRoutes.find((route) => {
        return route.pattern.replace(':?query:', '') === '';
    });
    let startupTargets = (_f = startupRoute === null || startupRoute === void 0 ? void 0 : startupRoute.target) !== null && _f !== void 0 ? _f : [];
    if (!Array.isArray(startupTargets)) {
        startupTargets = [startupTargets];
    }
    // Create page configurations in supported cases
    const appTargets = (_h = (_g = manifest['sap.ui5']) === null || _g === void 0 ? void 0 : _g.routing) === null || _h === void 0 ? void 0 : _h.targets;
    for (const targetKey in appTargets) {
        const pageConfig = createPageConfig(manifest, targetKey, opaConfig.appID);
        if (pageConfig) {
            pageConfig.isStartup = startupTargets.includes(targetKey);
            config.pages.push(pageConfig);
        }
    }
    return config;
}
/**
 * Finds the initial ListReport page and the first Object page from the app.
 *
 * @param pages - the page configs of the app
 * @param manifest - the app descriptor of the target app
 * @returns the page fonfigs for the LR and the OP if they're found
 */
function findLROP(pages, manifest) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const pageLR = pages.find((page) => {
        return page.isStartup && page.template === 'ListReport';
    });
    if (!pageLR) {
        return {};
    }
    const appTargets = (_b = (_a = manifest['sap.ui5']) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.targets;
    const appRoutes = ((_e = (_d = (_c = manifest['sap.ui5']) === null || _c === void 0 ? void 0 : _c.routing) === null || _d === void 0 ? void 0 : _d.routes) !== null && _e !== void 0 ? _e : []);
    const target = (appTargets && appTargets[pageLR.targetKey]);
    if (!((_g = (_f = target === null || target === void 0 ? void 0 : target.options) === null || _f === void 0 ? void 0 : _f.settings) === null || _g === void 0 ? void 0 : _g.navigation)) {
        return { pageLR }; // No navigation from LR
    }
    // Find all targets that can be navigated from the LR page
    const navigatedTargetKeys = [];
    for (const navKey in target.options.settings.navigation) {
        const navObject = target.options.settings.navigation[navKey];
        const navigatedRoute = ((_h = navObject.detail) === null || _h === void 0 ? void 0 : _h.route) &&
            appRoutes.find((route) => {
                var _a;
                return route.name === ((_a = navObject.detail) === null || _a === void 0 ? void 0 : _a.route);
            });
        if (Array.isArray(navigatedRoute === null || navigatedRoute === void 0 ? void 0 : navigatedRoute.target)) {
            navigatedTargetKeys.push(...navigatedRoute.target);
        }
        else if (navigatedRoute === null || navigatedRoute === void 0 ? void 0 : navigatedRoute.target) {
            navigatedTargetKeys.push(navigatedRoute.target);
        }
    }
    // Find the first navigated page that is valid and not the starting LR
    let pageOP;
    for (let i = 0; i < navigatedTargetKeys.length && !pageOP; i++) {
        if (navigatedTargetKeys[i] === pageLR.targetKey) {
            continue; // This can happen in the FCL case where the LR is also part of the route's targets to the OP
        }
        pageOP = pages.find((page) => {
            return page.targetKey === navigatedTargetKeys[i];
        });
    }
    return { pageLR, pageOP };
}
/**
 * Writes a page object in a mem-fs-editor.
 *
 * @param pageConfig - the page configuration object
 * @param rootTemplateDirPath - template root directory
 * @param testOutDirPath - output test directory (.../webapp/test)
 * @param fs - a reference to a mem-fs editor
 */
function writePageObject(pageConfig, rootTemplateDirPath, testOutDirPath, fs) {
    fs.copyTpl((0, path_1.join)(rootTemplateDirPath, `integration/pages/${pageConfig.template}.js`), (0, path_1.join)(testOutDirPath, `integration/pages/${pageConfig.targetKey}.js`), pageConfig, undefined, {
        globOptions: { dot: true }
    });
}
/**
 * Generate OPA test files for a Fiori elements for OData V4 application.
 * Note: this can potentially overwrite existing files in the webapp/test folder.
 *
 * @param basePath - the absolute target path where the application will be generated
 * @param opaConfig - parameters for the generation
 * @param opaConfig.scriptName - the name of the OPA journey file. If not specified, 'FirstJourney' will be used
 * @param opaConfig.htmlTarget - the name of the html that will be used in OPA journey file. If not specified, 'index.html' will be used
 * @param opaConfig.appID - the appID. If not specified, will be read from the manifest in sap.app/id
 * @param fs - an optional reference to a mem-fs editor
 * @returns Reference to a mem-fs-editor
 */
function generateOPAFiles(basePath, opaConfig, fs) {
    var _a, _b;
    const editor = fs || (0, mem_fs_editor_1.create)((0, mem_fs_1.create)());
    const manifest = readManifest(editor, basePath);
    const { applicationType, hideFilterBar } = getAppTypeAndHideFilterBarFromManifest(manifest);
    const config = createConfig(manifest, opaConfig, hideFilterBar);
    const rootCommonTemplateDirPath = (0, path_1.join)(__dirname, '../templates/common');
    const rootV4TemplateDirPath = (0, path_1.join)(__dirname, `../templates/${applicationType}`); // Only v4 is supported for the time being
    const testOutDirPath = (0, path_1.join)(basePath, 'webapp/test');
    // Common test files
    editor.copy((0, path_1.join)(rootCommonTemplateDirPath), testOutDirPath);
    // Integration (OPA) test files - version-specific
    editor.copyTpl((0, path_1.join)(rootV4TemplateDirPath, 'integration', 'opaTests.*.*'), (0, path_1.join)(testOutDirPath, 'integration'), config, undefined, {
        globOptions: { dot: true }
    });
    // Pages files (one for each page in the app)
    config.pages.forEach((page) => {
        writePageObject(page, rootV4TemplateDirPath, testOutDirPath, editor);
    });
    // OPA Journey file
    const startPages = config.pages.filter((page) => page.isStartup).map((page) => page.targetKey);
    const LROP = findLROP(config.pages, manifest);
    const journeyParams = {
        startPages,
        startLR: (_a = LROP.pageLR) === null || _a === void 0 ? void 0 : _a.targetKey,
        navigatedOP: (_b = LROP.pageOP) === null || _b === void 0 ? void 0 : _b.targetKey,
        hideFilterBar: config.hideFilterBar
    };
    editor.copyTpl((0, path_1.join)(rootV4TemplateDirPath, 'integration/FirstJourney.js'), (0, path_1.join)(testOutDirPath, `integration/${config.opaJourneyFileName}.js`), journeyParams, undefined, {
        globOptions: { dot: true }
    });
    return editor;
}
exports.generateOPAFiles = generateOPAFiles;
/**
 * Generate a page object file for a Fiori elements for OData V4 application.
 * Note: this doesn't modify other existing files in the webapp/test folder.
 *
 * @param basePath - the absolute target path where the application will be generated
 * @param pageObjectParameters - parameters for the page
 * @param pageObjectParameters.targetKey - the key of the target in the manifest file corresponding to the page
 * @param pageObjectParameters.appID - the appID. If not specified, will be read from the manifest in sap.app/id
 * @param fs - an optional reference to a mem-fs editor
 * @returns Reference to a mem-fs-editor
 */
function generatePageObjectFile(basePath, pageObjectParameters, fs) {
    const editor = fs || (0, mem_fs_editor_1.create)((0, mem_fs_1.create)());
    const manifest = readManifest(editor, basePath);
    const { applicationType } = getAppTypeAndHideFilterBarFromManifest(manifest);
    const pageConfig = createPageConfig(manifest, pageObjectParameters.targetKey, pageObjectParameters.appID);
    if (pageConfig) {
        const rootTemplateDirPath = (0, path_1.join)(__dirname, `../templates/${applicationType}`); // Only v4 is supported for the time being
        const testOutDirPath = (0, path_1.join)(basePath, 'webapp/test');
        writePageObject(pageConfig, rootTemplateDirPath, testOutDirPath, editor);
    }
    else {
        throw new types_1.ValidationError((0, i18n_1.t)('error.cannotGeneratePageFile', {
            targetKey: pageObjectParameters.targetKey
        }));
    }
    return editor;
}
exports.generatePageObjectFile = generatePageObjectFile;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 44749:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValidationError = exports.SupportedPageTypes = void 0;
exports.SupportedPageTypes = {
    'sap.fe.templates.ListReport': 'ListReport',
    'sap.fe.templates.ObjectPage': 'ObjectPage',
    'sap.fe.core.fpm': 'FPM'
};
/**
 * General validation error thrown if app config options contain invalid combinations
 */
class ValidationError extends Error {
    /**
     * ValidationError constructor.
     *
     * @param message - the error message
     */
    constructor(message) {
        super(`Validation error: ${message}`);
        this.name = this.constructor.name;
    }
}
exports.ValidationError = ValidationError;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 74940:
/***/ ((module) => {

module.exports = JSON.parse('{"error":{"cannotReadManifest":"Cannot read manifest file {{ filePath }}","cannotReadAppID":"Cannot read appID in the manifest file","badApplicationType":"Cannot determine application type from the manifest, or unsupported type","cannotGeneratePageFile":"Cannot generate page file for target {{ targetKey }}"}}');

/***/ })

};
;