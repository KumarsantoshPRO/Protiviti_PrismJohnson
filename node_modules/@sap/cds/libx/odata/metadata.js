const cds = require('../../lib')
const LOG = cds.log('odata')
const crypto = require('crypto')
const { join } = require ('path')

const _requestedFormat = (queryOption, header) => {
  if (queryOption) return queryOption.match(/json/i) ? 'json' : 'xml'
  if (header) {
    const jsonIndex = header.indexOf('application/json')
    if (jsonIndex === -1) return 'xml'
    const xmlIndex = header.indexOf('application/xml')
    if (xmlIndex === -1) return 'json'
    return jsonIndex < xmlIndex ? 'json' : 'xml'
  }
  return 'xml'
}

const _metadataFromFile = async srv => {
  const fs = require('fs')
  const filePath = cds.root + `/srv/odata/v4/${srv.name}.xml`
  let exists
  try {
    exists = !(await fs.promises.access(filePath, fs.constants.F_OK))
  } catch (e) {
    LOG._debug && LOG.debug(`No metadata file found for service ${srv.name} at ${filePath}`)
  }
  if (exists) {
    const file = await fs.promises.readFile(filePath)
    return file.toString()
  }
}

const normalize_header = value => {
  return value.split(',').map(str => str.trim())
}

const validate_etag = (ifNoneMatch, etag) => {
  const ifNoneMatchEtags = normalize_header(ifNoneMatch)
  return ifNoneMatchEtags.includes(etag) || ifNoneMatchEtags.includes('*')
}

const generateEtag = s => {
  return `W/"${crypto.createHash('sha256').update(s).digest('base64')}"`
}

const odata_error = (code, message) => ({ error: { code, message } })

const mpSupportsEmptyLocale = () => {   
  const pkg = require(join('@sap/cds-mtxs', 'package.json'))  
  const version = pkg.version.match(/^(\d+\.)?(\d+\.)?(\*|\d+)$/).map(Number)
  return version[1] > 1 || (version[1] === 1 && version[2] >= 12)
}

module.exports = srv =>
  async function metadata(req, res, next) {
    if (req.path === '/$metadata') {
      if (req.method !== 'GET')
        return res
          .status(405)
          .json(odata_error('METHOD_NOT_ALLOWED', `Method ${req.method} not allowed for $metadata.`))

      const tenant = cds.context.tenant
      const locale = cds.context.locale
      const format = _requestedFormat(req.query['$format'], req.headers['accept'])

      // REVISIT: edm(x) and etag cache is only evicted with model
      const csnService = (cds.context.model || cds.model).definitions[srv.name]
      const metadataCache = (csnService.metadataCache = csnService.metadataCache || { jsonEtag: {}, xmlEtag: {} })

      const etag = format === 'json' ? metadataCache.jsonEtag?.[locale] : metadataCache.xmlEtag?.[locale]

      if (req.headers['if-none-match']) {
        if (etag) {
          const unchanged = validate_etag(req.headers['if-none-match'], etag)
          if (unchanged) {
            res.set('Etag', etag)
            return res.status(304).end()
          }
        }
      }

      const { 'cds.xt.ModelProviderService': mps } = cds.services
      if (mps) {
        if (format === 'json')
          res
            .status(400)
            .json(
              odata_error(
                'UNSUPPORTED_METADATA_TYPE',
                'JSON metadata is not supported if cds.requires.extensibilty: true.'
              )
            )

        try {
          let edmx
          // REVISIT: remove check later
          if (mpSupportsEmptyLocale()) {
            edmx = metadataCache.edm || await mps.getEdmx({ tenant, model: srv.model, service: srv.definition.name })
            metadataCache.edm = edmx
            const extBundle = cds.env.requires.extensibility && await mps.getI18n({ tenant, locale })
            edmx = cds.localize(srv.model, locale, edmx, extBundle)
          } else {
            edmx = await mps.getEdmx({ tenant, model: srv.model, service: srv.definition.name, locale })
          }
          metadataCache.xmlEtag[locale] = generateEtag(edmx)
          res.set('Content-Type', 'application/xml')
          res.send(edmx)
          return
        } catch (e) {
          if (LOG._error) {
            e.message = 'Unable to get EDMX for tenant ' + tenant + ' due to error: ' + e.message
            LOG.error(e)
          }

          return res.status(503).json(odata_error('SERVICE_UNAVAILABLE', 'Service unavailable'))
        }
      }

      if (format === 'json') {
        const edm =
          metadataCache.edm || (metadataCache.edm = cds.compile.to.edm(srv.model, { service: srv.definition.name }))
        const localized = cds.localize(srv.model, locale, edm)
        metadataCache.jsonEtag[locale] = generateEtag(localized)
        return res.json(JSON.parse(localized))
      }

      const edmx =
        metadataCache.edmx ||
        (await _metadataFromFile(srv)) ||
        (metadataCache.edmx = cds.compile.to.edmx(srv.model, { service: srv.definition.name }))
      const localized = cds.localize(srv.model, locale, edmx)
      metadataCache.xmlEtag[locale] = generateEtag(localized)
      res.set('Etag', metadataCache.xmlEtag[locale])
      res.set('Content-Type', 'application/xml')
      return res.send(localized)
    }
    return next()
  }
