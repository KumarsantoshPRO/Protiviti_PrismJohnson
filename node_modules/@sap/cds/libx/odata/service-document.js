const crypto = require('crypto')
const cds = require('../../lib')

const normalize_header = value => {
  return value.split(',').map(str => str.trim())
}

const validate_etag = (ifNoneMatch, etag) => {
  const ifNoneMatchEtags = normalize_header(ifNoneMatch)
  return ifNoneMatchEtags.includes(etag) || ifNoneMatchEtags.includes('*')
}

const generateEtag = s => {
  return `W/"${crypto.createHash('sha256').update(s).digest('base64')}"`
}

module.exports = srv =>
  function service_document(req, res, next) {
    if (req.path === '/') {
      if (req.method === 'HEAD') return res.end()
      if (req.method !== 'GET')
        return res
          .status(405)
          .json({
            error: { code: 'METHOD_NOT_ALLOWED', message: `Method ${req.method} not allowed for service document.` }
          })

      const m = cds.context.model || cds.model
      const csnService = (cds.context.model || cds.model).definitions[srv.name]

      if (req.headers['if-none-match']) {
        if (csnService.srvDocEtag) {
          const unchanged = validate_etag(req.headers['if-none-match'], csnService.srvDocEtag)
          if (unchanged) {
            res.set('Etag', csnService.srvDocEtag)
            return res.status(304).end()
          }
        }
      }

      const srvEntities = m.childrenOf(srv.name)
      // REVISIT: How to identify the exposed entities? api.ignore, autoexposed, ...
      const exposedEntities = Object.keys(srvEntities).filter(
        e => !srvEntities[e]['@cds.api.ignore'] && e !== 'DraftAdministrativeData'
      )

      csnService.srvDocEtag = generateEtag(JSON.stringify(exposedEntities))
      res.set('Etag', csnService.srvDocEtag)
      return res.json({
        '@odata.context': `$metadata`,
        '@odata.metadataEtag': csnService.srvDocEtag,
        value: exposedEntities.map(e => {
          const e_ = e.replace(/\./g, '_')
          return { name: e_, url: e_ }
        })
      })
    }

    return next()
  }
