const { extend } = require('../lazy')

class any {

  constructor(...aspects) { Object.assign (this,...aspects) }
  set name(n) { this.set('name', n, false) }
  set kind(k) { this.set('kind', k, true) }
  get kind() { return this.set('kind', this.parent ? 'element' : 'type') }
  is (kind) { return this.kind === kind || kind === 'any' }
  valueOf() { return this.name }

  own (property, ifAbsent) {
    const pd = Reflect.getOwnPropertyDescriptor (this, property)
    if (pd) return pd.value //|| pd.get(this)
    if (ifAbsent) return this.set (property, ifAbsent())
  }

  set (property, value, enumerable = false) {
    Reflect.defineProperty (this, property, { value, enumerable, writable:1, configurable:1 })
    return value
  }

  dataIn (d, prefix='') {
    return d[prefix + this.name]
  }
}

class type extends any {}
class action extends any {}
class context extends any {}

class service extends context {

  static _protocols = []
  get endpoints() { return super.endpoints = service.endpoints4(this) }
  get path() { return super.path = service.path4(this) }

  /**
   * Return the first service endpoint path to mount it to
   */
  static path4 (srv, options = {}) {
    return this.endpoints4(srv, options)[0]?.path
  }

  /**
   * Return an array of protocol names to be served by the given service.
   * Ensure that 'odata' shortcuts are expanded to 'odata-v4'.
   */
  static protocols4 (def, options = {}) {
    const ov4 = p => p === 'odata' ? 'odata-v4' : p

    if (options.to) return [ov4(options.to)]

    const protocols = this._protocols
    if (def) {
      // Check @protocol annotation
      let atProtocol = def['@protocol']
      if (atProtocol === 'none') return []
      if (atProtocol) {
        const result = (Array.isArray(atProtocol) ? atProtocol : [atProtocol]).map(p => ov4(typeof p === 'string' ? p : p.kind))
        return [...new Set(result)]
      }

      // Check @odata, @rest, ... shortcuts
      const shortcut = Object.keys(protocols).find(p => def['@'+p])
      if (shortcut) return [ov4(shortcut)]
    }

    // No protocol annotation found -> serve odata
    return ['odata-v4']
  }

  static endpoints4 (srv, options = {}) {
    const def = srv?.definition || srv
    if (!def) return []

    // Return a sluggified variant of the service's name
    const pathFromServiceName4 = (srv) => {
      return (
        /[^.]+$/.exec(srv.name)[0]  //> my.very.CatalogService --> CatalogService
        .replace(/Service$/,'')     //> CatalogService --> Catalog
        .replace(/_/g,'-')          //> foo_bar_baz --> foo-bar-baz
        .replace(/([a-z0-9])([A-Z])/g, (_,c,C) => c+'-'+C)  //> ODataFooBarX9 --> OData-Foo-Bar-X9
        .toLowerCase()              //> FOO --> foo
      )
    }

    // Return an array of service paths for a given service and protocol.
    // The results are not prefixed with the protocol's path.
    // Can return multiple results to support serving the same protocol on multiple paths:
    // `@protocol: [{kind: 'odata', path: '/a'}, {kind: 'odata', path: '/b'}]`
    const unprefixedPaths4 = (protocol, srv, options) => {
      const def = srv?.definition || srv
      if (options.at) return [options.at]
      if (options.path) return [options.path]

      const atProtocol = def['@protocol']
      if (atProtocol) {
        let paths = []
        let protocols = Array.isArray(atProtocol) ? atProtocol : [atProtocol]
        for (let p of protocols) {
          let pName = (p.kind || p) === 'odata' ? 'odata-v4' : p.kind || p
          if (pName === protocol) {
            if (p.path) paths.push(p.path)
            else paths.push(def['@path'] || pathFromServiceName4(srv))
          }
        }

        // in case protocol is set via options.at but not contained in @protocol
        if (paths.length === 0) paths.push(def['@path'] || pathFromServiceName4(srv))

        return paths
      }

      if (def['@path']) return [def['@path']]
      return [pathFromServiceName4(srv)]
    }

    const protocols = this.protocols4(def, options)

    if (protocols.length > 1 && def['@path']?.[0] === '/') {
      throw new Error(`Absolute @path (starting with '/') cannot be set for more than one protocol`)
    }

    const endpoints = [], env_protocols = global.cds?.env.protocols
    const serve_on_root = global.cds?.env.features.serve_on_root

    for (let each of protocols) {
      let p = this._protocols[each] || env_protocols[each]
      if (!p) throw new Error(`Protocol "${each}" is unknown`)

      const middlewares = global.cds?.requires.middlewares
      const kind = each
      let prefix = middlewares ? p.path || '/' : '/' // > no middlewares, no prefix
      if (!prefix.endsWith('/')) prefix += '/'
      const unprefixedPaths = unprefixedPaths4(each, srv, options)
      for (let path of unprefixedPaths) {
        if (path.startsWith('/')) endpoints.push({ kind, path})
        else {
          // Extra serve in root if serve_on_root=true, but not(!) in case of ...
          //   - multiple protocols
          //   - empty prefix, which is the case for legacy protocol adapter
          //   - middlewares=false (check only needed for handling of custom protocols)
          if (middlewares && serve_on_root && protocols.length === 1 && prefix !== '/') endpoints.push({ kind, path: '/' + path })
          endpoints.push({ kind, path: prefix + path })
        }
      }
    }
    return endpoints
  }
}

class array extends type { is(kind) { return kind === 'array' || super.is(kind) }}
class aspect extends type { is(kind) { return kind === 'aspect' || super.is(kind) }}
class event extends aspect{}

class struct extends aspect {
  is(kind) { return kind === 'struct' || super.is(kind) }

  /**
   * Gets the foreign key data for a given managed association from inbound data
   * in structured form.
   *
   * @example
   * let { Books } = srv.entities
   * let { author } = Books.elements
   * let book = { // inbound data, e.g. from req.data
   *   title: 'Foo',
   *   author_ID: 111
   * }
   * let value = author.dataIn(book)
   * //> { ID: 111 }
   *
   * Actually this works for all struct-like elements, i.e., which's definitions
   * have .elements or .foreignKeys. Could be added to cds.struct/cds.Association.
   */
  dataIn (d, prefix='', _skip_root) {
    const key = prefix + this.name; if (!_skip_root && key in d) return d[key]
    const elements = this.elements || this.foreignKeys // REVISIT: .foreignKeys should be .elements
    const nested={}, key_ = _skip_root ? '' : key+'_'
    let any; for (let e in elements) {
      const v = elements[e] .dataIn (d,key_)
      if (v !== undefined) nested[any=e] = v
    }
    if (any) return !prefix && d._hull ? d._hull[key] = nested : nested
  }

  /**
   * Returns a Proxy for provided data which adds getters to return values
   * for struct elements (including Associations) in structured form.
   *
   * @example
   * let { Books } = m.entities
   * let data = Books.data ({
   *   author: {ID:111},
   *   genre_ID: 22
   * })
   * console.log ('author:', data.author) //> { ID: 111 }
   * console.log ('genre:', data.genre)  //> { ID: 22 }
   */
   data (d) {
    if (_proxy in d) return d[_proxy] //> use cached proxy, if exists

    // hull to cache calculated values without polluting original input
    const _hull = {__proto__:d}

    // allow external code to access _hull
    Object.defineProperty (_hull, '_hull', {value:_hull})

    // proxy calls def.dataIn() for defined elements, fallback hull[p]
    const {elements} = this, proxy = new Proxy (d, {
      get: (_,p) => elements[p]?.dataIn(_hull) || _hull[p],
    })

    // cache proxy with original data
    Object.defineProperty (d, _proxy, {value:proxy})

    return proxy
  }

}
const _proxy = Symbol('_proxy')


/**
 * Export is a dictionary of all builtin classes
 */
module.exports = {

  any,
  type,
  array,
  aspect,
  struct,
  context,
  service,
  action,
  event,

  /**
   * Allows to mixin functions or properties to several equally named builtin classes
   * @example
   * cds.builtin.classes.mixin (
   *  	class any { foo(){} },
   *  	class entity { bar(){} }
   * )
   */
  mixin(...classes) { for (let each of classes) {
    const clazz = this[each.name]
    if (!clazz) throw new Error(`unknown class '${each.name}'`)
    extend(clazz).with(each)
  }},
}
