'use strict';

const { isBetaEnabled } = require('../../base/model');
const { CompilerAssertion } = require('../../base/error');
const { makeMessageFunction } = require('../../base/messages');
const { cloneCsnNonDict, getUtils, isAspect } = require('../../model/csnUtils');
const transformUtils = require('../transformUtils');
const flattening = require('../db/flattening');
const types = require('./types');
// const { addLocalizationViews } = require('../../transform/localized');
const validate = require('../../checks/validator');
const expansion = require('../db/expansion');
const queries = require('./queries');
const associations = require('./associations');
const generateDrafts = require('../draft/db');
const handleExists = require('../db/transformExists');
const misc = require('./misc');
const { rewriteCalculatedElementsInViews, processCalculatedElementsInEntities } = require('../db/rewriteCalculatedElements');

/**
 * This is just a PoC for now!
 *
 * Transform the given CSN into a so called effective CSN, by
 * - dissolving structured types
 * - turning managed into unmanaged associations
 * @private
 * @param {CSN.Model} model Input CSN - will not be transformed
 * @param {CSN.Options} options
 * @returns {CSN.Model}
 */
function effectiveCsn( model, options ) {
  if (!isBetaEnabled(options, 'effectiveCsn'))
    throw new CompilerAssertion('effective CSN is only supported with beta flag `effectiveCsn`!');

  const csn = cloneCsnNonDict(model, options);

  delete csn.vocabularies; // must not be set for effective CSN

  const { expandStructsInExpression } = transformUtils.getTransformers(csn, options, '_');
  queries.projectionToSELECTAndAddColumns(csn);

  let csnUtils = getUtils(csn, 'init-all');
  const messageFunctions = makeMessageFunction(csn, options, 'for.effective');

  // Run validations on CSN - each validator function has access to the message functions and the inspect ref via this
  const cleanup = validate.forRelationalDB(csn, {
    ...messageFunctions, csnUtils, ...csnUtils, csn, options, isAspect,
  });

  rewriteCalculatedElementsInViews(csn, options, csnUtils, '_', messageFunctions);

  // Needs to happen before tuple expansion, so the newly generated WHERE-conditions have it applied
  handleExists(csn, options, messageFunctions.error, csnUtils.inspectRef, csnUtils.initDefinition, csnUtils.dropDefinitionCache);

  // Check if structured elements and managed associations are compared in an expression
  // and expand these structured elements. This tuple expansion allows all other
  // subsequent procession steps to see plain paths in expressions.
  // If errors are detected, throwWithAnyError() will return from further processing
  expandStructsInExpression(csn, { drillRef: true });

  messageFunctions.throwWithAnyError();

  // Expand a structured thing in: keys, columns, order by, group by
  expansion.expandStructureReferences(csn, options, '_', messageFunctions, csnUtils);

  const resolveTypesInActionsAfterFlattening = types.resolve(csn, csnUtils);

  csnUtils = getUtils(csn, 'init-all');

  // Remove properties attached by validator - they do not "grow" as the model grows.
  cleanup();

  flattening.flattenAllStructStepsInRefs(csn, options, new WeakMap(), '_');
  flattening.flattenElements(csn, options, '_', messageFunctions.error);

  resolveTypesInActionsAfterFlattening();

  // ensure getElement works on flattened struct_assoc columns
  csnUtils = getUtils(csn, 'init-all');

  processCalculatedElementsInEntities(csn);
  associations.managedToUnmanaged(csn, options, csnUtils, messageFunctions);
  associations.transformBacklinks(csn, options, csnUtils, messageFunctions);
  generateDrafts(csn, options, '_', messageFunctions);
  misc.attachPersistenceName(csn, options, csnUtils);
  misc.removeDefinitionsAndProperties(csn);

  messageFunctions.throwWithError();

  return csn;
}

module.exports = { effectiveCsn };
