'use strict';

// This file contains functions related to XSN/CSN-location objects,
// but not semantic locations (which are message-specific),

const { copyPropIfExist } = require('../utils/objectUtils');
const { CsnLocation } = require('../compiler/classes');

/**
 * Create a location with properties `file`, `line` and `col` from argument
 * `start`, and properties `endLine` and `endCol` from argument `end`.
 *
 * @param {XSN.WithLocation} start
 * @param {XSN.WithLocation} end
 * @returns {CSN.Location}
 *
 * TODO: make this function a CDL parser-only function (i.e. there should be
 *       no need to use it outside), it is XSN-only anyway already now
 */
function combinedLocation( start, end ) {
  if (!start || !start.location)
    return end.location;
  else if (!end || !end.location)
    return start.location;
  const loc = {
    file: start.location.file,
    line: start.location.line,
    col: start.location.col,
  };
  copyPropIfExist(end.location, 'endLine', loc);
  copyPropIfExist(end.location, 'endCol', loc);
  return loc;
}

/**
 * Create an empty location object with the given file name.
 *
 * @param {string} filename
 * @returns {CSN.Location}
 *
 * TODO: make this function redundant (XSN sparse locations project)
 */
function emptyLocation( filename ) {
  return {
    __proto__: CsnLocation.prototype,
    file: filename,
    line: 1,
    col: 1,
    endLine: 1,
    endCol: 1,
  };
}

/**
 * Create an empty location object with the given file name.
 * The end line/column is not set and therefore the location is weak.
 *
 * @param {string} filename
 * @returns {CSN.Location}
 *
 * TODO: make this function redundant (XSN sparse locations project)
 */
function emptyWeakLocation( filename ) {
  return {
    __proto__: CsnLocation.prototype,
    file: filename,
    line: 1,
    col: 1,
    endLine: undefined,
    endCol: undefined,
  };
}

/**
 * @param {CsnLocation} loc
 * @returns {CsnLocation}
 */
function weakLocation( loc ) {
  return (!loc?.endLine) ? loc : {
    __proto__: CsnLocation.prototype,
    file: loc.file,
    line: loc.line,
    col: loc.col,
    endLine: undefined,
    endCol: undefined,
  };
}

/**
 * Return a location to be used for compiler-generated artifacts whose location is
 * best derived from a reference (`type`, `includes`, `target`, `value`) or a name.
 * Omit the end position to indicate that this is just an approximate location.
 *
 * If represented by a `path` (not always the case for a `name`), use the location
 * of its last item.  Reason: think of an IDE functionality “Go to Definition” – only
 * a double-click on the _last_ identifier token of the reference jumps to the artifact
 * represented by the complete reference.
 *
 * @param {CsnLocation} loc
 * @returns {CsnLocation}
 */
function weakRefLocation( ref ) {
  if (!ref)
    return ref;
  const { path } = ref;
  const loc = path?.length ? path[path.length - 1].location : ref.location;
  return (!loc?.endLine) ? loc : {
    __proto__: CsnLocation.prototype,
    file: loc.file,
    line: loc.line,
    col: loc.col,
    endLine: undefined,
    endCol: undefined,
  };
}

/**
 * @param {CsnLocation} loc
 * @returns {CsnLocation}
 */
function weakEndLocation( loc ) {
  return loc && {
    __proto__: CsnLocation.prototype,
    file: loc.file,
    line: loc.endLine,
    col: loc.endCol && loc.endCol - 1,
    endline: undefined,
    endCol: undefined,
  };
}

/**
 * Returns a dummy location for built-in definitions.
 *
 * @returns {CSN.Location}
 *
 * TODO: make this function redundant (XSN sparse locations project)
 */
function builtinLocation() {
  return emptyLocation('<built-in>');
}

/**
 * Return gnu-style error string for location `loc`:
 *  - 'File:Line:Col' without `loc.end`
 *  - 'File:Line:StartCol-EndCol' if Line = start.line = end.line
 *  - 'File:StartLine.StartCol-EndLine.EndCol' otherwise
 *
 * @param {CSN.Location|CSN.Location} location
 * @param {boolean} [normalizeFilename]
 */
function locationString( location, normalizeFilename ) {
  if (!location)
    return '<???>';
  const loc = location;
  const filename = (loc.file && normalizeFilename)
    ? loc.file.replace( /\\/g, '/' )
    : loc.file;
  if (!(loc instanceof Object))
    return loc;
  if (!loc.line) {
    return filename;
  }
  else if (!loc.endLine) {
    return (loc.col)
      ? `${ filename }:${ loc.line }:${ loc.col }`
      : `${ filename }:${ loc.line }`;
  }

  return (loc.line === loc.endLine)
    ? `${ filename }:${ loc.line }:${ loc.col }-${ loc.endCol }`
    : `${ filename }:${ loc.line }.${ loc.col }-${ loc.endLine }.${ loc.endCol }`;
}

/**
 * Return the source location of the complete dictionary `dict`.  If
 * `extraLocation` is truthy, also consider this location.
 * ASSUMPTION: all entries in the dictionary have a property `location` and
 * `location.file` has always the same value.
 *
 * TODO: remove this function - if we really want to have dictionary locations,
 * set them in the CDL parser, e.g. via a symbol.
 *
 * @param {object} dict
 * @param {CSN.Location} [extraLocation]
 * @returns {CSN.Location}
 */
function dictLocation( dict, extraLocation ) {
  if (!dict)
    return extraLocation;

  if (!Array.isArray(dict))
    dict = Object.getOwnPropertyNames( dict ).map( name => dict[name] );

  /** @type {CSN.Location[]} */
  const locations = [].concat( ...dict.map( _objLocations ) );
  if (extraLocation)
    locations.push( extraLocation );

  const min = locations.reduce( (a, b) => (a.line < b.line || (a.line === b.line && a.col < b.col) ? a : b) );
  const max = locations.reduce( (a, b) => {
    const lineA = (a.endLine || a.line);
    const lineB = (b.endLine || b.line);
    return (lineA > lineB || (lineA === lineB && (a.endCol || a.col) > (b.endCol || b.col)) ? a : b);
  });
  return new CsnLocation( min.file, min.line, min.col, max.endLine, max.endCol );
}

function _objLocations( obj ) {
  return Array.isArray(obj) ? obj.map( o => o.location ) : [ obj.location ];
}

module.exports = {
  combinedLocation,
  emptyLocation,
  emptyWeakLocation,
  weakLocation,
  weakRefLocation,
  weakEndLocation,
  builtinLocation,
  dictLocation,
  locationString,
};
