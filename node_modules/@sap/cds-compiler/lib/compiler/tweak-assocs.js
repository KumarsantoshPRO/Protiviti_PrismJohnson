// Tweak associations: rewrite keys and on conditions

'use strict';

const {
  forEachGeneric,
  forEachInOrder,
} = require('../base/model');
const { dictLocation, weakLocation, weakRefLocation } = require('../base/location');

const {
  setLink,
  setArtifactLink,
  linkToOrigin,
  copyExpr,
  forEachUserArtifact,
  forEachQueryExpr,
  traverseQueryPost,
  traverseQueryExtra,
  setExpandStatus,
} = require('./utils');
const { CsnLocation } = require('./classes');
const { CompilerAssertion } = require('../base/error');

const $location = Symbol.for( 'cds.$location' );
const $inferred = Symbol.for( 'cds.$inferred' );

// Export function of this file.
function tweakAssocs( model ) {
  // Get shared functionality and the message function:
  const {
    info, warning, error,
  } = model.$messageFunctions;
  const {
    traverseExpr,
    checkExpr,
    checkOnCondition,
    effectiveType,
    getOrigin,
  } = model.$functions;

  // Phase 5: rewrite associations
  model._entities.forEach( rewriteArtifact );
  // Think hard whether an on condition rewrite can lead to a new cyclic
  // dependency.  If so, we need other messages anyway.  TODO: probably dox
  // another cyclic check with testMode.js
  forEachUserArtifact( model, 'definitions', function check( art ) {
    checkOnCondition( art.on, (art.kind !== 'mixin' ? 'on' : 'mixin-on'), art );
    checkExpr( art.value, (art.$syntax === 'calc' ? 'calc' : 'column'), art );

    if (art.kind === 'select')
      forEachQueryExpr( art, checkExpr );
  } );
  return;


  //--------------------------------------------------------------------------
  // Phase 5: rewrite associations
  //--------------------------------------------------------------------------
  // Only top-level queries and sub queries in FROM

  function rewriteArtifact( art ) {
    // return;
    if (!art.query) {
      // console.log(message( null, art.location, art, {target:art._target},
      //   'Info','RAS').toString())
      rewriteAssociation( art );
      forEachGeneric( art, 'elements', rewriteAssociation );
    }
    else {
      traverseQueryExtra( art, ( query ) => {
        forEachGeneric( query, 'elements', rewriteAssociation );
      } );
    }
    if (art._service)
      forEachGeneric( art, 'elements', complainAboutTargetOutsideService );

    traverseQueryPost( art.query, false, ( query ) => {
      forEachGeneric( query, 'elements', rewriteAssociationCheck );
    } );
  }

  // function rewriteView( view ) {
  //   // TODO: we could sort according to the $effectiveSeqNo instead
  //   // (and then remove traverseQueryExtra)
  //   if (view.includes)          // entities with structure includes:
  //     forEachGeneric( view, 'elements', rewriteAssociation );
  // }

  // Check explicit ON / keys with REDIRECTED TO
  // TODO: run on all queries, but this is potentially incompatible
  // function rewriteViewCheck( view ) {
  //   traverseQueryPost( view.query, false, ( query ) => {
  //     forEachGeneric( query, 'elements', rewriteAssociationCheck );
  //   } );
  // }

  function complainAboutTargetOutsideService( elem ) {
    const target = elem.target && elem.target._artifact;
    if (!target || target._service) // assoc to other service is OK
      return;
    const loc = [ elem.target.location, elem ];
    const main = elem._main || elem;
    if (!elem.$inferred && !main.$inferred) {
      info( 'assoc-target-not-in-service', loc,
            { target, '#': (elem._main.query ? 'select' : 'define') }, {
              std: 'Target $(TARGET) of association is outside any service', // not used
              // eslint-disable-next-line max-len
              define: 'Target $(TARGET) of explicitly defined association is outside any service',
              // eslint-disable-next-line max-len
              select: 'Target $(TARGET) of explicitly selected association is outside any service',
            } );
    }
    else {
      const text = main.$inferred === 'autoexposed' ? 'exposed' : 'std';
      // ID published! Used in stakeholder project; if renamed, add to oldMessageIds
      info( 'assoc-outside-service', loc, { '#': text, target, service: main._service }, {
        std: 'Association target $(TARGET) is outside any service',
        // eslint-disable-next-line max-len
        exposed: 'If association is published in service $(SERVICE), its target $(TARGET) is outside any service',
      } );
    }
  }

  function rewriteAssociationCheck( element ) {
    const elem = element.items || element; // TODO v5: nested items
    if (elem.elements)
      forEachGeneric( elem, 'elements', rewriteAssociationCheck );
    if (!elem.target)
      return;
    if (elem.on && !elem.on.$inferred) {
      const assoc = getOrigin( elem );
      if (assoc && assoc.foreignKeys) {
        error( 'rewrite-key-for-unmanaged', [ elem.on.location, elem ],
               { keyword: 'on', art: assocWithExplicitSpec( assoc ) },
               // eslint-disable-next-line max-len
               'Do not specify an $(KEYWORD) condition when redirecting the managed association $(ART)' );
      }
      checkIgnoredFilter( elem );
    }
    else if (elem.foreignKeys && !inferredForeignKeys( elem.foreignKeys )) {
      const assoc = getOrigin( elem );
      if (assoc?.on) {
        error( 'rewrite-on-for-managed',
               [ elem.foreignKeys[$location] || dictLocation( elem.foreignKeys ), elem ],
               { art: assocWithExplicitSpec( assoc ) },
               'Do not specify foreign keys when redirecting the unmanaged association $(ART)' );
      }
      else if (assoc?.foreignKeys) {
        // same sequence is not checked
        rewriteKeysMatch( elem, assoc );
        rewriteKeysCovered( assoc, elem );
      }

      checkIgnoredFilter( elem );
    }
  }

  /**
   * Publishing an association with filters is allowed, but the filter is ignored
   * if the association is redirected.  That indicates modeling mistakes, so we
   * emit a warning.
   */
  function checkIgnoredFilter( elem ) {
    const lastStep = elem.value?.path?.[elem.value.path.length - 1];
    if (lastStep?.where) {
      const loc = lastStep.where.location;
      const variant = elem.foreignKeys ? 'fKey' : 'onCond';
      warning( 'query-ignoring-filter', [ loc, elem ], { '#': variant } );
    }
  }

  function rewriteKeysMatch( thisAssoc, otherAssoc ) {
    const { foreignKeys } = thisAssoc;
    for (const name in foreignKeys) {
      if (otherAssoc.foreignKeys[name])
        continue;               // we would do a basic type check later
      const key = foreignKeys[name];
      const baseAssoc = assocWithExplicitSpec( otherAssoc );
      if (inferredForeignKeys( baseAssoc.foreignKeys )) { // still inferred = via target keys
        error( 'rewrite-key-not-matched-implicit', [ key.name.location, key ],
               { name, target: baseAssoc.target },
               'No key $(NAME) is defined in original target $(TARGET)' );
      }
      else {
        error( 'rewrite-key-not-matched-explicit', [ key.name.location, key ],
               { name, art: baseAssoc },
               'No foreign key $(NAME) is specified in association $(ART)' );
      }
    }
  }

  function rewriteKeysCovered( thisAssoc, otherAssoc ) {
    const names = [];
    const { foreignKeys } = thisAssoc;
    for (const name in foreignKeys) {
      if (!otherAssoc.foreignKeys[name])
        names.push( name );
    }
    if (names.length) {
      const loc = otherAssoc.foreignKeys[$location] || dictLocation( otherAssoc.foreignKeys );
      const location = loc && (!loc.endCol
        ? loc
        : new CsnLocation( loc.file, loc.endLine, loc.endCol - 1, loc.endLine, loc.endCol ));
      const baseAssoc = assocWithExplicitSpec( thisAssoc );
      if (inferredForeignKeys( baseAssoc.foreignKeys )) { // still inferred = via target keys
        error( 'rewrite-key-not-covered-implicit', [ location, otherAssoc ],
               { names, target: baseAssoc.target },
               {
                 std: 'Specify keys $(NAMES) of original target $(TARGET) as foreign keys',
                 one: 'Specify key $(NAMES) of original target $(TARGET) as foreign key',
               } );
      }
      else {
        error( 'rewrite-key-not-covered-explicit', [ location, otherAssoc ],
               { names, art: otherAssoc },
               {
                 std: 'Specify foreign keys $(NAMES) of association $(ART)',
                 one: 'Specify foreign key $(NAMES) of association $(ART)',
               } );
      }
    }
  }

  function assocWithExplicitSpec( assoc ) {
    while (assoc.foreignKeys && inferredForeignKeys( assoc.foreignKeys, 'keys' ) ||
           assoc.on && assoc.on.$inferred)
      assoc = getOrigin( assoc );
    return assoc;
  }

  function rewriteAssociation( element ) {
    let elem = element.items || element; // TODO v5: nested items
    if (elem.elements)
      forEachGeneric( elem, 'elements', rewriteAssociation );
    if (!originTarget( elem ))
      return;
    // console.log(message( null, elem.location, elem,
    // {art:assoc,target,ftype:JSON.stringify(ftype)}, 'Info','RA').toString())

    // With cyclic dependencies on select items, testing for the _effectiveType to
    // be 0 (test above) is not enough if we we have an explicit redirection
    // target -> avoid infloop ourselves with _status.
    // TODO: this should be good now
    const chain = [];
    while (!elem.on && !elem.foreignKeys) {
      chain.push( elem );
      if (elem._status === 'rewrite') { // circular dependency (already reported)
        for (const e of chain)
          setLink( e, '_status', null ); // XSN TODO: nonenum _status -> enum $status
        return;
      }
      setLink( elem, '_status', 'rewrite' );
      elem = getOrigin( elem );
      if (!elem || elem.builtin) // safety
        return;
    }
    chain.reverse();
    for (const art of chain) {
      setLink( elem, '_status', null );
      if (elem.on)
        rewriteCondition( art, elem );
      else if (elem.foreignKeys)
        rewriteKeys( art, elem );

      if (art.on)
        removeManagedPropsFromUnmanaged( art );

      elem = art;
    }
  }

  /**
   * Remove properties from unmanaged association `elem` that are only valid
   * on managed associations.  Only set to `NULL` (special value for propagator),
   * if necessary, i.e. the value is set on the `_origin`-chain.
   */
  function removeManagedPropsFromUnmanaged( elem ) {
    removeProp( 'notNull' );
    removeProp( 'default' );

    function removeProp( prop ) {
      let origin = elem;
      while (origin) {
        if (origin[prop]) { // regardless of the value, reset the property
          const location = weakLocation( elem.name.location );
          elem[prop] = { $inferred: 'NULL', val: undefined, location };
          break;
        }
        origin = origin._origin;
      }
    }
  }

  function originTarget( elem ) {
    const assoc = !elem.expand && getOrigin( elem );
    const ftype = assoc && effectiveType( assoc );
    return ftype && ftype.target && ftype.target._artifact;
  }

  function inferredForeignKeys( foreignKeys, ignore ) {
    return foreignKeys[$inferred] && foreignKeys[$inferred] !== ignore;
  }

  function rewriteKeys( elem, assoc ) {
    // TODO: split this function: create foreign keys without `targetElement`
    // already in Phase 2: redirectImplicitly()
    // console.log(message( null, elem.location, elem, {art:assoc,target:assoc.target},
    //  'Info','FK').toString())
    elem.foreignKeys = Object.create(null); // set already here (also for zero foreign keys)
    forEachInOrder( assoc, 'foreignKeys', ( orig, name ) => {
      const location = weakRefLocation( elem.target );
      const fk = linkToOrigin( orig, name, elem, 'foreignKeys', location );
      fk.$inferred = 'rewrite'; // Override existing value; TODO: other $inferred value?
      setLink( fk, '_effectiveType', fk );
      const te = copyExpr( orig.targetElement, location );
      if (elem._redirected) {
        const i = te.path[0];   // TODO: or also follow path like for ON?
        const state = rewriteItem( elem, i, i.id, elem, true );
        if (state && state !== true && te.path.length === 1)
          setArtifactLink( te, state );
      }
      fk.targetElement = te;
    } );
    if (elem.foreignKeys) // Possibly no fk was set
      elem.foreignKeys[$inferred] = 'rewrite';

    addConditionFromAssocPublishing( elem, assoc );
  }

  // TODO: there is no need to rewrite the on condition of non-leading queries,
  // i.e. we could just have on = {…}
  // TODO: re-check $self rewrite (with managed composition of aspects),
  // and actually also $self inside anonymous aspect definitions
  // (not entirely urgent as we do not analyse it further, at least sole "$self")
  function rewriteCondition( elem, assoc ) {
    // the ON condition might need to be rewritten even if the target stays the
    // same (TODO later: set status whether rewrite changes anything),
    // especially problematic are refs starting with $self:
    setExpandStatus( elem, 'target' );
    if (elem._parent?.kind === 'element') {
      // managed association as sub element not supported yet
      error( null, [ elem.location, elem ], {},
        // eslint-disable-next-line max-len
             'Rewriting the ON-condition of unmanaged association in sub element is not supported' );
      return;
    }
    const nav = (elem._main?.query && elem.value)
      ? pathNavigation( elem.value ) // redirected source elem or mixin
      : { navigation: assoc };       // redirected user-provided
    const cond = copyExpr( assoc.on,
      // replace location in ON except if from mixin element
                           nav.tableAlias && elem.name.location );
    elem.on = cond;
    addConditionFromAssocPublishing( elem, assoc );
    // `cond` still points to the original condition; does not include possible assoc filter
    elem.on.$inferred = 'copy';

    const { navigation } = nav;
    if (!navigation) // TODO: what about $projection.assoc as myAssoc ?
      return;                 // should not happen: $projection, $magic, or ref to const
    // Currently, having an unmanaged association inside a struct is not
    // supported by this function:
    if (navigation !== assoc && navigation._origin !== assoc) { // TODO: re-check
      // For "assoc1.assoc2" and "struct.elem1.assoc2"
      if (elem._redirected !== null) // null = already reported
        error( 'rewrite-not-supported', [ elem.target.location, elem ] );
      return;
    }
    if (!nav.tableAlias || nav.tableAlias.path) {
      traverseExpr( cond, 'rewrite-on', elem,
                    expr => rewriteExpr( expr, elem, nav.tableAlias ) );
    }
    else {
      // TODO: support that, now that the ON condition is rewritten in the right order
      error( null, [ elem.value.location, elem ], {},
             'Selecting unmanaged associations from a sub query is not supported' );
    }
    elem.on.$inferred = 'rewrite';
  }

  /**
   * If an unmanaged association is being published, we add a potential
   * filter to the ON-condition and use its cardinality.
   * If a managed association is published, we transform it into an unmanaged
   * and do the same.
   *
   * The added condition (filter) is already rewritten relative to `elem`.
   */
  function addConditionFromAssocPublishing( elem, assoc ) {
    const publishAssoc = (elem._main?.query && elem.value?.path?.length > 0);
    if (!publishAssoc)
      return;

    const { location } = elem.name;
    const lastStep = elem.value.path[elem.value.path.length - 1];

    if (lastStep?.cardinality) {
      if (!elem.cardinality)
        elem.cardinality = assoc.cardinality || { location };
      for (const card of [ 'sourceMin', 'targetMin', 'targetMax' ]) {
        if (lastStep.cardinality[card])
          elem.cardinality[card] = copyExpr( lastStep.cardinality[card], location );
      }
    }

    if (lastStep?.where) {
      // If there are foreign keys, transform them into an ON-condition first.
      if (assoc.foreignKeys) {
        const cond = foreignKeysToOnCondition( elem );
        if (cond) {
          elem.on = cond;
          elem.foreignKeys = undefined;
        }
      }

      if (elem.on) {
        elem.on = {
          op: { val: 'and', location },
          args: [
            // TODO: Get rid of $parens
            { ...elem.on, $parens: [ assoc.location ] },
            filterToCondition( lastStep, elem ),
          ],
          location,
          $inferred: 'copy',
        };
      }
    }
  }

  /**
   * Transform a filter on `assoc` into an ON-condition.
   * Paths inside the filter are rewritten relative to `elem`.
   */
  function filterToCondition( assoc, elem ) {
    const cond = copyExpr( assoc.where );
    // TODO: Get rid of $parens
    cond.$parens = [ assoc.location ];
    traverseExpr( cond, 'rewrite-filter', elem, (expr) => {
      if (!expr.path || expr.path.length === 0)
        return;

      const root = expr.path[0]._navigation || expr.path[0]._artifact;
      if (!root)
        return; // only for compile error, e.g. missing definition
      if (root.kind === '$self') {
        // $projection -> $self for recompilability
        expr.path[0].id = '$self';
      }
      else if (!root.builtin && root.kind !== 'builtin') {
        expr.path.unshift({
          id: elem.name.id,
          location: elem.name.location,
        });
        setLink( expr.path[0], '_artifact', elem );
        // _navigation link not necessary because this condition is not rewritten
        // inside the same view (would otherwise be needed for mixins).

        if (elem.name.id.charAt(0) === '$')
          prependSelfToPath( expr.path, elem );
      }
    } );

    checkOnCondition( cond, 'on', elem );
    return cond;
  }

  // Caller must ensure ON-condition correctness via rewriteExpr()!
  function foreignKeysToOnCondition( elem ) {
    const nav = pathNavigation( elem.value );
    if (!nav.tableAlias && model.options.testMode && !elem._pathHead)
      throw new CompilerAssertion('rewriting keys to ON-condition: no tableAlias but not inline');

    if (!nav.tableAlias || elem._parent?.kind === 'element' ||
       (nav && nav.item !== elem.value.path[elem.value.path.length - 1])) {
      // - no nav.tableAlias for mixins or inside inline; mixins can't have managed assocs, though.
      // - _parent is element for expand
      // - nav.item is different for multi-path steps e.g. `sub.assoc`, which is not supported, yet
      // TODO: Support this
      error( 'rewrite-not-supported', [ elem.value.location, elem ] );
      return null;
    }

    let cond = [];
    forEachInOrder( elem, 'foreignKeys', function keyToCond( fKey ) {
      // Format:      lhs = rhs
      //         assoc.id = assoc_id
      // lhs and rhs look the same, but have different ids and _artifact links.
      // rhs is rewritten further down to ensure that the foreign key is projected.
      const lhs = {
        path: [
          { id: elem.name.id, location: elem.name.location },
          ...copyExpr( fKey.targetElement.path ),
        ],
        location: elem.name.location,
      };
      setLink( lhs.path[0], '_artifact', elem ); // different to rhs!
      setLink( lhs, '_artifact', lhs.path[lhs.path.length - 1] );

      if (elem.name.id.charAt(0) === '$')
        prependSelfToPath( lhs.path, elem );

      const rhs = {
        path: [
          // use origin's name; elem could have alias
          { id: elem._origin.name.id, location: elem._origin.name.location },
          ...copyExpr( fKey.targetElement.path ),
        ],
        location: elem.name.location,
      };
      setLink( rhs.path[0], '_artifact', elem._origin ); // different to lhs!
      setLink( rhs, '_artifact', rhs.path[rhs.path.length - 1] );

      // Can't use rewriteExpr as that would use `assoc[…]` itself as well.
      const projectedFk = firstProjectionForPath( rhs.path, nav.tableAlias, elem );
      rewritePath( rhs, projectedFk.item, elem, projectedFk.elem, elem.value.location );

      const fkCond = {
        op: { val: 'ixpr', location: elem.name.location },
        args: [
          lhs,
          { val: '=', literal: 'token', location: elem.name.location },
          rhs,
        ],
        location: elem.name.location,
      };
      cond.push(fkCond);
    } );

    if (cond.length === 0) {
      const lastStep = elem.value.path[elem.value.path.length - 1];
      error( 'expr-missing-foreign-key', [ lastStep.location, elem ], {
        '#': 'publishingFilter',
        id: lastStep.id,
      } );
      return null;
    }

    cond = (cond.length === 1) ? cond[0]
      : {
        op: { val: 'and', location: elem.name.location },
        args: cond,
        location: elem.name.location,
      };

    return cond;
  }

  function rewriteExpr( expr, assoc, tableAlias ) {
    // Rewrite ON condition (resulting in outside perspective) for association
    // 'assoc' in query or including entity from ON cond of mixin element /
    // element in included structure / element in source ref/d by table alias.

    // TODO: complain about $self (unclear semantics)
    // console.log( info(null, [assoc.name.location, assoc],
    //       { art: expr._artifact, names: expr.path.map(i=>i.id) }, 'A').toString(), expr.path)

    if (!expr.path || !expr._artifact)
      return;
    if (!assoc._main)
      return;
    if (tableAlias) { // from ON cond of element in source ref/d by table alias
      const source = tableAlias._origin;
      const root = expr.path[0]._navigation || expr.path[0]._artifact;
      if (!root || root._main !== source)
        return;                 // not $self or source element
      if (expr.scope === 'param' || root.kind === '$parameters')
        return;                 // are not allowed anyway - there was an error before
      const result = firstProjectionForPath( expr.path, tableAlias, assoc );
      // For `assoc[…]`, ensure that we don't rewrite to another projection on `assoc`.
      if (result.item && assoc._origin === result.item._artifact)
        result.elem = assoc;

      rewritePath( expr, result.item, assoc, result.elem, assoc.value.location );
    }
    else if (assoc._main.query) { // from ON cond of mixin element in query
      const root = expr.path[0]._navigation || expr.path[0]._artifact;
      if (expr.scope === 'param' || root?.kind === '$parameters') {
        if (assoc.$errorReported !== 'assoc-unexpected-scope') {
          error( 'assoc-unexpected-scope', [ assoc.value.location, assoc ],
                 { id: assoc.value._artifact.name.id },
                 // eslint-disable-next-line max-len
                 'Association $(ID) can\'t be projected because its ON-condition refers to a parameter' );
          assoc.$errorReported = 'assoc-unexpected-scope';
        }
        return;
      }
      const nav = pathNavigation( expr );
      if (nav.navigation || nav.tableAlias) { // rewrite src elem, mixin, $self[.elem]
        const elem = (assoc._origin === root) ? assoc : navProjection( nav.navigation, assoc );
        rewritePath( expr, nav.item, assoc, elem,
                     nav.item ? nav.item.location : expr.path[0].location );
      }
    }
    else {                     // from ON cond of element in included structure
      const root = expr.path[0]._navigation || expr.path[0]._artifact;
      if (root.builtin || root.kind !== '$self' && root.kind !== 'element')
        return;
      const item = expr.path[root.kind === '$self' ? 1 : 0];
      if (!item)
        return;                                   // just $self
      // corresponding elem in including structure
      const elem = (assoc._main.items || assoc._main).elements[item.id];
      if (!elem)
        return; // See #11755
      if (!(Array.isArray( elem ) ||            // no msg for redefs
            elem === item._artifact ||          // redirection for explicit def
            elem._origin === item._artifact)) {
        const art = assoc._origin;
        warning( 'rewrite-shadowed', [ elem.name.location, elem ],
                 { art: art && effectiveType( art ) },
                 {
                   // eslint-disable-next-line max-len
                   std: 'This element is not originally referred to in the ON-condition of association $(ART)',
                   // eslint-disable-next-line max-len
                   element: 'This element is not originally referred to in the ON-condition of association $(MEMBER) of $(ART)',
                 } );
      }
      rewritePath( expr, item, assoc, (Array.isArray( elem ) ? false : elem), null );
    }
  }

  function rewritePath( ref, item, assoc, elem, location ) {
    const { path } = ref;
    const root = path[0];
    if (!elem) {
      if (location) {
        const elemref = root._navigation?.kind === '$self' ? path.slice(1) : path;
        error( 'rewrite-not-projected', [ location, assoc ], {
          name: assoc.name.id, art: item._artifact, elemref: { ref: elemref },
        }, {
          std: 'Projected association $(NAME) uses non-projected element $(ELEMREF)',
          element: 'Projected association $(NAME) uses non-projected element $(ELEMREF) of $(ART)',
        } );
      }
      delete root._navigation;
      setArtifactLink( root, elem );
      setArtifactLink( ref, elem );
      return;
    }
    if (item !== root) {
      // e.g. mixin ON-condition: Base.foo -> $self.foo or multi-path projection,
      // $projection -> $self
      root.id = '$self';
      setLink( root, '_navigation', assoc._parent.$tableAliases.$self );
      setArtifactLink( root, assoc._parent );
      if (item) {
        const i = path.indexOf(item);
        ref.path = [ root, ...path.slice( i, path.length ) ];
      }
    }
    else if (elem.name.id.charAt(0) === '$') {
      prependSelfToPath( path, assoc );
    }
    else {
      setLink( root, '_navigation', elem );
    }
    if (!elem.name)      // nothing to do for own $projection, $projection.elem
      return;            // (except having it renamed to $self)
    item.id = elem.name.id;
    let state = null;
    for (const i of path) {
      if (!state) {
        if (i === item)
          state = setArtifactLink( i, elem );
      }
      else if (i) {
        state = rewriteItem( state, i, i.id, assoc );
        if (!state || state === true)
          break;
      }
      else {
        return;
      }
    }
    if (state !== true)
      setArtifactLink( ref, state );
  }

  function prependSelfToPath( path, elem ) {
    const root = { id: '$self', location: path[0].location };
    path.unshift( root );
    setLink( root, '_navigation', elem._parent.$tableAliases.$self );
    setArtifactLink( root, elem._parent );
  }

  function rewriteItem( elem, item, name, assoc, forKeys ) {
    if (!elem._redirected)
      return true;
    for (const alias of elem._redirected) {
      // TODO: a message for the same situation as msg 'rewrite-shadowed'?
      if (alias.kind === '$tableAlias') { // _redirected also contains structures for includes
        // TODO: if there is a "multi-step" redirection, we should probably
        // consider intermediate "preferred" elements - not just `assoc`,
        // but its origins, too.
        const proj = navProjection( alias.elements[name], assoc );
        name = proj?.name?.id;
        if (!name) {
          if (!forKeys)
            break;
          setArtifactLink( item, null );
          const culprit = elem.target && !elem.target.$inferred && elem.target ||
                          elem.value?.path?.[elem.value.path.length - 1] ||
                          elem;
          // TODO: probably better to collect the non-projected foreign keys
          // and have one message for all
          error( 'rewrite-undefined-key', [ weakLocation( culprit.location ), assoc ],
                 { id: item.id, art: alias._main },
                 'Foreign key $(ID) has not been found in target $(ART)' );
          return null;
        }
        item.id = name;
      }
    }
    let env = name && elem._effectiveType; //  should have been computed
    // refs in ON cannot navigate along `items`, no need to consider `items` here
    if (env?.target)
      env = env.target._artifact?._effectiveType;
    elem = setArtifactLink( item, env?.elements?.[name] );

    if (elem && !Array.isArray( elem ))
      return elem;
    // TODO: better (extra message), TODO: do it
    error( 'query-undefined-element', [ item.location, assoc ],
           { id: name || item.id, '#': 'redirected' } );
    return (elem) ? false : null;
  }
}

function navProjection( navigation, preferred ) {
  // TODO: Info if more than one possibility?
  // console.log(navigation,navigation._projections)
  if (!navigation)
    return {};
  else if (!navigation._projections)
    return null;
  return (preferred && navigation._projections.includes( preferred ))
    ? preferred
    : navigation._projections[0] || null;
}


/**
 * For a path `a.b.c.d`, return a projection for the first path item that is projected.
 * For example, if a query has multiple projections such as `a.b, a, a.b.c`, the
 * _first_ possible projection will be used and the caller can rewrite `a.b.c.d` to `b.c.d`.
 * This avoids that `extend`s affect the ON-condition.
 *
 * The returned object `ret` has `ret.item`, which is the path item that is projected.
 * `ret.elem` is the element projection.
 *
 * @param {any[]} path
 * @param {object} tableAlias
 * @param {object} assoc Preferred association that should be used if projected.
 * @return {{elem: object, item: object}|null}
 */
function firstProjectionForPath( path, tableAlias, assoc ) {
  const viaSelf = (path[0]._navigation || path[0]._artifact).kind === '$self';
  const root = viaSelf ? 1 : 0;
  if (root >= path.length) // e.g. just `$self` path item
    return { item: undefined, elem: {} };

  // We want to use the _first_ valid projection that is written by the user (if the preferred
  // `assoc` is not directly projected).  To achieve that, look into the table alias' elements.
  const selectedElements = Object.values(tableAlias._parent.elements);
  const proj = [];
  let navItem = tableAlias;
  for (const item of path.slice(root)) {
    navItem = item?.id && navItem.elements?.[item.id];
    if (!navItem) {
      break;
    }
    else if (navItem._projections) {
      const elem = navProjection( navItem, assoc );
      if (elem && elem === assoc) {
        // in case the specified association is found, _always_ use it.
        return { item, elem };
      }
      else if (elem) {
        const index = selectedElements.indexOf(elem);
        proj.push({ item, elem, index });
      }
    }
  }

  return (proj.length === 0)
    ? { item: path[root], elem: null }
    : proj.reduce( (acc, curr) => (acc.index > curr.index ? curr : acc), proj[0] ); // first
}

/**
 * Return condensed info about reference in select item
 * - tableAlias.elem       -> { navigation: navElem, item: path[1], tableAlias }
 * - sourceElem (in query) -> { navigation: navElem, item: path[0], tableAlias }
 * - mixinElem             -> { navigation: mixinElement, item: path[0] }
 * - $projection.elem      -> also $self.item -> { item: path[1], tableAlias: $self }
 * - $self                 -> { item: undefined, tableAlias: $self }
 * - $parameters.P, :P     -> {}
 * - $now, current_date    -> {}
 * - undef, redef          -> {}
 * With 'navigation': store that navigation._artifact is projected
 * With 'navigation': rewrite its ON condition
 * With navigation: Do KEY propagation
 *
 * TODO: re-think this function, copied in populate.js and tweak-assocs.js
 */
function pathNavigation( ref ) {
  // currently, indirectly projectable elements are not included - we might
  // keep it this way!  If we want them to be included - be aware: cycles
  if (!ref._artifact)
    return {};
  let item = ref.path && ref.path[0];
  const root = item && item._navigation;
  if (!root)
    return {};
  if (root.kind === '$navElement')
    return { navigation: root, item, tableAlias: root._parent };
  if (root.kind === 'mixin')
    return { navigation: root, item };
  item = ref.path[1];
  if (root.kind === '$self')
    return { item, tableAlias: root };
  if (root.kind !== '$tableAlias' || ref.path.length < 2)
    return {};                // should not happen
  return { navigation: root.elements[item.id], item, tableAlias: root };
}

module.exports = tweakAssocs;
